// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countNotes = `-- name: CountNotes :one
select count(*) from notes where user_id = $1
`

func (q *Queries) CountNotes(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteNote = `-- name: DeleteNote :exec
delete from notes where id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteNote, id)
	return err
}

const deleteTokens = `-- name: DeleteTokens :exec
delete from tokens where expires < current_timestamp
`

func (q *Queries) DeleteTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteTokens)
	return err
}

const insertNote = `-- name: InsertNote :one
insert into notes (id, user_id, title, category, content) values ($1, $2, $3, $4, $5) returning id, created, updated, user_id, title, category, content
`

type InsertNoteParams struct {
	ID       uuid.UUID `json:"id"`
	UserID   uuid.UUID `json:"user_id"`
	Title    string    `json:"title"`
	Category string    `json:"category"`
	Content  string    `json:"content"`
}

func (q *Queries) InsertNote(ctx context.Context, arg InsertNoteParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, insertNote,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Category,
		arg.Content,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.Title,
		&i.Category,
		&i.Content,
	)
	return i, err
}

const insertToken = `-- name: InsertToken :one
insert into tokens (id, expires, target, callback) values ($1, $2, $3, $4) returning id, expires, target, callback
`

type InsertTokenParams struct {
	ID       string    `json:"id"`
	Expires  time.Time `json:"expires"`
	Target   string    `json:"target"`
	Callback string    `json:"callback"`
}

func (q *Queries) InsertToken(ctx context.Context, arg InsertTokenParams) (Token, error) {
	row := q.db.QueryRowContext(ctx, insertToken,
		arg.ID,
		arg.Expires,
		arg.Target,
		arg.Callback,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Expires,
		&i.Target,
		&i.Callback,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
insert into users (id, email, access, sub, avatar) values ($1, $2, $3, $4, $5) returning id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end
`

type InsertUserParams struct {
	ID     uuid.UUID `json:"id"`
	Email  string    `json:"email"`
	Access int64     `json:"access"`
	Sub    string    `json:"sub"`
	Avatar string    `json:"avatar"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.Access,
		arg.Sub,
		arg.Avatar,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
	)
	return i, err
}

const ping = `-- name: Ping :one
select 1
`

func (q *Queries) Ping(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, ping)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const selectNote = `-- name: SelectNote :one
select id, created, updated, user_id, title, category, content from notes where id = $1
`

func (q *Queries) SelectNote(ctx context.Context, id uuid.UUID) (Note, error) {
	row := q.db.QueryRowContext(ctx, selectNote, id)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.Title,
		&i.Category,
		&i.Content,
	)
	return i, err
}

const selectNotes = `-- name: SelectNotes :many
select id, created, updated, user_id, title, category, content from notes where user_id = $1 order by created desc limit $2 offset $3
`

type SelectNotesParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) SelectNotes(ctx context.Context, arg SelectNotesParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, selectNotes, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.UserID,
			&i.Title,
			&i.Category,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectToken = `-- name: SelectToken :one
select id, expires, target, callback from tokens where id = $1
`

func (q *Queries) SelectToken(ctx context.Context, id string) (Token, error) {
	row := q.db.QueryRowContext(ctx, selectToken, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Expires,
		&i.Target,
		&i.Callback,
	)
	return i, err
}

const selectUser = `-- name: SelectUser :one
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end from users where id = $1
`

func (q *Queries) SelectUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
	)
	return i, err
}

const selectUserByCustomerID = `-- name: SelectUserByCustomerID :one
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end from users where customer_id = $1
`

func (q *Queries) SelectUserByCustomerID(ctx context.Context, customerID string) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUserByCustomerID, customerID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
	)
	return i, err
}

const selectUserByEmailAndSub = `-- name: SelectUserByEmailAndSub :one
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end from users where email = $1 and sub = $2
`

type SelectUserByEmailAndSubParams struct {
	Email string `json:"email"`
	Sub   string `json:"sub"`
}

func (q *Queries) SelectUserByEmailAndSub(ctx context.Context, arg SelectUserByEmailAndSubParams) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUserByEmailAndSub, arg.Email, arg.Sub)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
	)
	return i, err
}

const selectUsers = `-- name: SelectUsers :many
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end from users
`

func (q *Queries) SelectUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, selectUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Email,
			&i.Phone,
			&i.Access,
			&i.Sub,
			&i.Avatar,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.SubscriptionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNote = `-- name: UpdateNote :one
update notes set title = $1, category = $2, content = $3 where id = $4 returning id, created, updated, user_id, title, category, content
`

type UpdateNoteParams struct {
	Title    string    `json:"title"`
	Category string    `json:"category"`
	Content  string    `json:"content"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, updateNote,
		arg.Title,
		arg.Category,
		arg.Content,
		arg.ID,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.Title,
		&i.Category,
		&i.Content,
	)
	return i, err
}

const updateToken = `-- name: UpdateToken :exec
update tokens set expires = $1 where id = $2 returning id, expires, target, callback
`

type UpdateTokenParams struct {
	Expires time.Time `json:"expires"`
	ID      string    `json:"id"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateToken, arg.Expires, arg.ID)
	return err
}

const updateUserAccess = `-- name: UpdateUserAccess :one
update users set access = $1 where id = $2 returning id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end
`

type UpdateUserAccessParams struct {
	Access int64     `json:"access"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserAccess(ctx context.Context, arg UpdateUserAccessParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserAccess, arg.Access, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
	)
	return i, err
}

const updateUserActivity = `-- name: UpdateUserActivity :exec
update users set updated = current_timestamp where id = $1
`

func (q *Queries) UpdateUserActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserActivity, id)
	return err
}

const updateUserCustomerID = `-- name: UpdateUserCustomerID :exec
update users set customer_id = $1 where id = $2
`

type UpdateUserCustomerIDParams struct {
	CustomerID string    `json:"customer_id"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserCustomerID(ctx context.Context, arg UpdateUserCustomerIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUserCustomerID, arg.CustomerID, arg.ID)
	return err
}

const updateUserPhone = `-- name: UpdateUserPhone :exec
update users set phone = $2 where id = $1
`

type UpdateUserPhoneParams struct {
	ID    uuid.UUID `json:"id"`
	Phone string    `json:"phone"`
}

func (q *Queries) UpdateUserPhone(ctx context.Context, arg UpdateUserPhoneParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPhone, arg.ID, arg.Phone)
	return err
}

const updateUserSubscription = `-- name: UpdateUserSubscription :exec
update users set access = $1, subscription_id = $2, subscription_end = $3 where customer_id = $4
`

type UpdateUserSubscriptionParams struct {
	Access          int64     `json:"access"`
	SubscriptionID  string    `json:"subscription_id"`
	SubscriptionEnd time.Time `json:"subscription_end"`
	CustomerID      string    `json:"customer_id"`
}

func (q *Queries) UpdateUserSubscription(ctx context.Context, arg UpdateUserSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSubscription,
		arg.Access,
		arg.SubscriptionID,
		arg.SubscriptionEnd,
		arg.CustomerID,
	)
	return err
}
